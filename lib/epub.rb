# Epub
#
# Used for making directories, moving files, parsing templates; 
# sets up the epub and then generates .epub file (using zip)
#
# Final .epub generation requires a Book object that has at least one Chapter object in it
#
# Basically, there are two ways to use this now:
# 1. You have a templates directory (such as the one generated by the epubbery executable)
#    In this case, you're looking to load up templates using load_file_templates and 
#    then you can create_zip
# 2. You want to load in templates and css out of memory (or db) and custom build the epub.
#    In this case, you need to load_custom_templates, then custom_asset_files
#    and then when you create_zip, you're going to need almost all of the options
#
class Epub
  class << self
    # kind of an orphaned method that just reads in chapters from text files 
    # and returns chapter objects
    def read_chapters(file_glob)
      file_glob = File.expand_path(file_glob)
      puts "Reading files: #{file_glob} (#{Dir[file_glob].size} files found)"
      chapters = []

      Dir[file_glob].each do |txtfile|
        chapter = nil
        File.open(txtfile) do |f|
          chapter = Chapter.new(f.readlines)
          chapter.file_name = "#{File.basename(txtfile, '.txt').gsub(/\W/,'_')}.html"
        end
        chapters << chapter if chapter
      end

      # returns chapters as an array sorted by number or file_name
      chapters.sort
    end
  end

  # only useful for setting up the generation of actual HTML files
  # not used in the current version of the gem (HTML is generated in memory, 
  # not written to files)
  def make_skeleton(base_dir, epub_folder, default_template = 'chapter')
    default_template ||= 'chapter'
    @epub_folder = epub_folder
    @source_templates_dir = File.join(base_dir, 'templates')
    @target_meta_dir = File.join(@epub_folder, 'META-INF')
    @target_oebps_dir = File.join(@epub_folder, 'OEBPS')

    FileUtils.rm_rf @epub_folder if File.exists?(@epub_folder)
    FileUtils.mkdir_p @epub_folder
    FileUtils.mkdir_p @target_meta_dir
    FileUtils.mkdir_p @target_oebps_dir

    FileUtils.cp File.join(@source_templates_dir, 'META-INF', 'container.xml'), 
      @target_meta_dir

    # TODO - somehow detect these "asset" folders and files - 
    # for now they are these defaults: css, images, fonts
    FileUtils.cp Dir[File.join(@source_templates_dir, 'OEBPS', '*.css')], 
      @target_oebps_dir
    FileUtils.cp_r File.join(@source_templates_dir, 'OEBPS', 'images'), 
      @target_oebps_dir
    FileUtils.cp_r File.join(@source_templates_dir, 'OEBPS', 'fonts'), 
      @target_oebps_dir

    load_file_templates(base_dir, default_template)
  end

  # load liquid templates from files in the templates directory
  def load_file_templates(base_dir, default_template = 'chapter')
    @source_templates_dir ||= File.join(base_dir, 'templates')

    # liquid templates for rest of files
    default = File.read(File.join(@source_templates_dir, 'OEBPS', 
              "#{default_template.gsub(' ', '_')}.html.liquid" ))
    content = File.read(File.join(@source_templates_dir, 'OEBPS', 
              'content.opf.liquid'))
    title = File.read(File.join(@source_templates_dir, 'OEBPS', 'title.html.liquid'))
    toc = File.read(File.join(@source_templates_dir, 'OEBPS', 'toc.ncx.liquid'))
    eob = File.read(File.join(@source_templates_dir, 'OEBPS', 
              'end_of_book.html.liquid'))

    load_custom_templates(default, content, title, toc, eob)
  end

  # load liquid templates, manually (provide String objects from memory or db)
  # * default: default template for all chapters (html)
  # * content: template for content.opf (xml)
  # * title: title page (html)
  # * toc: table of contents (for toc.ncx, xml)
  # * eob: end of book page (html)
  def load_custom_templates(default, content, title, toc, eob)
    @default_liq_template = Liquid::Template.parse(default)
    @content_liq_template = Liquid::Template.parse(content)
    @title_liq_template   = Liquid::Template.parse(title)
    @toc_liq_template     = Liquid::Template.parse(toc)
    @eob_liq_template     = Liquid::Template.parse(eob)
  end

  # optionally provide arrays of each asset type (directory path not necessary); 
  # if you don't use this, the gem will try to scan for default directories
  def custom_asset_files(css_files, image_files, font_files)
    @css_files = css_files
    @image_files = image_files
    @font_files = font_files
  end

  # currently only used for testing - this method actually writes the 
  # html files to disk
  def write_templates(book)
    rendered_templates = render_templates(book)
    rendered_templates.each do |filepath, text|
      puts "Writing: #{@epub_folder}/#{filepath}"
      File.open(File.join(@epub_folder, filepath), "w") { |f| f.puts text }
    end
  end

  # _book_ is a Book object with at least one Chapter in it and _zipfile_ is the file path 
  # to the .epub that will be generated (warning, any existing file will get overwritten)
  #
  # _options_:
  #   css_asset_loc: file path to the css asset files (defaults to templates/OEBPS)
  #   image_asset_loc: file path to the image asset files (defaults to templates/OEBPS/images)
  #   font_asset_loc: file path to the font asset files (defaults to templates/OEBPS/fonts)
  #   container_loc: file path to container.xml
  #   css_buffers: a hash in the form { 'file_name.css' => 'body { color: #999 }' }
  #     (note, css_buffers will override css_asset_loc)
  #   extra_templates: a hash in the form { 'template name' => 'raw liquid stuff' }
  #     (hint: to avoid directory scans for templates, pass extra templates or an empty hash)
  def create_zip(book, zipfile, options = {})
    unless book.chapters and !book.chapters.empty?
      raise "Unable to create zip file: Your book has no chapters!"
    end

    begin
      image_asset_loc = options[:image_asset_loc] || File.join(@source_templates_dir, 'OEBPS', 'images')
      font_asset_loc = options[:font_asset_loc] || File.join(@source_templates_dir, 'OEBPS', 'fonts')
      container_loc = options[:container_loc] || File.join(@source_templates_dir, 'META-INF', 'container.xml')
      rendered_templates = render_templates(book, options[:extra_templates])
    rescue Exception => e
      raise "source_templates_dir was not found; provide more options\n" + 
        "  (css_asset_loc or css_buffers, image_asset_loc, font_asset_loc, container_loc,\n" + 
        "  extra_templates)\n" + 
        "(Original error: #{e.class} - #{e})"
    end


    # instead of creating a zip file from scratch, we start with the base epub zipfile, 
    # make a copy and then add files to it
    FileUtils.cp File.join(gem_dir, 'lib', 'base.epub'), zipfile
    Zip::Archive.open(zipfile) do |ar|
      ar.add_file 'META-INF/container.xml', container_loc
      if options[:css_buffers]
        @css_files.each do |f|
          ar.add_buffer "OEBPS/#{f}", options[:css_buffers][f]
        end
      else
        css_asset_loc = options[:css_asset_loc] || File.join(@source_templates_dir, 'OEBPS')
        @css_files.each do |f|
          ar.add_file "OEBPS/#{f}", File.join(css_asset_loc, f)
        end
      end
      @image_files.each do |f|
        ar.add_file "OEBPS/images/#{f}", File.join(image_asset_loc, f)
      end
      @font_files.each do |f|
        ar.add_file "OEBPS/fonts/#{f}", File.join(font_asset_loc, f)
      end
      rendered_templates.each do |filepath, text|
        puts "Adding: #{filepath}"
        ar.add_buffer filepath, text
      end  
    end
  end

  private
  def gem_dir
    @gem_dir ||= File.expand_path(File.dirname(__FILE__) + '/..')
  end

  # finds css, images, fonts in templates directory. 
  # only used when custom_asset_files has not been loaded
  def find_asset_files
    @css_files = Dir[File.join(@source_templates_dir, 'OEBPS', '*.css')].
      map { |f| File.basename(f) }
    @image_files = Dir[File.join(@source_templates_dir, 'OEBPS', 'images', '*')].
      map { |f| File.basename(f) }
    @font_files = Dir[File.join(@source_templates_dir, 'OEBPS', 'fonts', '*')].
      map { |f| File.basename(f) }
  end

  # returns a hash where the keys are file paths and the values are rendered templates
  # provide extra templates in the form of a hash: 
  #   { 'name' => 'liquid template string' }
  # if you don't provide extra templates, we scan the templates dir for them
  def render_templates(book, extra_templates = nil)
    unless extra_templates
      # scan the source folder for html liquid templates
      extra_templates = {}
      Dir[File.join(@source_templates_dir, 'OEBPS', '*.html.liquid')].each do |f|
        friendly_name = File.basename(f).gsub('_', ' ').gsub('.html.liquid', '')
        extra_templates[friendly_name] = File.read(f)
      end
    end

    rendered = {}

    unless @css_files and @image_files and @font_files
      begin
        find_asset_files
      rescue Exception => e
        raise "Unable to file asset files: use custom_asset_files first\n" + 
          "(Original error: #{e.class} - #{e})"
      end
    end

    book.chapters.each do |chapter|
      template = @default_liq_template
      # if this chapter has a specific template AND we can find it, use it
      if chapter.template and extra_templates[chapter.template.downcase]
        template = Liquid::Template.parse(extra_templates[chapter.template.downcase])
      end
      html_output = template.render 'chapter' => chapter
      puts "Rendering: OEBPS/#{chapter.file_name}"
      rendered[File.join('OEBPS', chapter.file_name)] = html_output
    end

    puts "Rendering: OEBPS/content.opf"
    # content.opf template needs to know location of asset files
    rendered[File.join('OEBPS', 'content.opf')] = @content_liq_template.render(
        'book' => book,
        'css_files'   => @css_files,
        'image_files' => @image_files,
        'font_files'  => @font_files )

    puts "Rendering: OEBPS/title.html"
    rendered[File.join('OEBPS', 'title.html')] = @title_liq_template.render(
        'book' => book)

    puts "Rendering: OEBPS/end_of_book.html"
    rendered[File.join('OEBPS', 'end_of_book.html')] = @eob_liq_template.render(
        'book' => book) 

    puts "Rendering: OEBPS/toc.ncx"
    rendered[File.join('OEBPS', 'toc.ncx')] = @toc_liq_template.render(
        'book' => book) 

    rendered
  end

end

